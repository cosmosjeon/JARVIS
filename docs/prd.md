# JARVIS 최종 기획서 (v3.1, 최종 종합 상세본)

## 1.0 개요 (Overview)

### 1.1. 제품 비전
JARVIS는 사용자의 의식 흐름을 방해하지 않으면서 지적 호기심을 포착하고, 이를 체계적인 지식 구조로 시각화하여 심층적인 학습을 유도하는 '지능형 학습 트리 도구'이다. 사용자는 어떤 컨텍스트(웹, PDF, 코드)에서든 즉시 질문을 던지고, AI의 답변에서 파생되는 새로운 질문들을 가지치기하며 자신만의 지식 지도를 구축한다.

### 1.2. 핵심 가치

- **비간섭성 (Non-intrusive)**: `Ctrl`x2 핫키 하나로 모든 것을 시작하여 작업 흐름의 중단을 최소화한다.
- **비용 효율성 (Cost-effective)**: 답변이 꼭 필요할 때만 AI를 호출하는 'Placeholder' 개념으로 불필요한 비용과 시간 낭비를 막는다.
- **구조화된 탐색 (Structured Exploration)**: 단발적인 Q&A를 넘어, 질문과 답변이 유기적으로 연결된 마인드맵 트리를 통해 지식의 '폭'과 '깊이'를 동시에 탐색한다.
- **영구 자산화 (Permanent Asset)**: 모든 탐색의 과정은 '라이브러리 앱'에 자동으로 저장 및 아카이빙되어, 언제든 다시 꺼내보고 확장할 수 있는 개인의 지식 자산이 된다.

## 2.0 핵심 컨셉 정의 (Core Concept Definitions)

### 2.1. 플로팅 에이전트 (Floating Agent)
사용자의 주 작업 화면 위에 떠 있는 소형 UI. `Ctrl`x2 핫키로 호출되며, 처음에는 **오직 질문 입력 패널로만 구성**된다. 사용자의 즉각적인 질문을 입력받고, 첫 답변 생성 후에는 현재 노드와 직계 자식들을 보여주는 **'포커스 트리 뷰'**를 함께 제공한다. 창 자체는 **크기 조절이 가능**하며, 창 영역에 **마우스를 호버했을 때만 닫기(X) 버튼이 노출**된다. 창을 닫으면 현재 세션은 라이브러리 앱에 자동 저장된다.

### 2.2. 라이브러리 앱 (Library App)
JARVIS의 모든 지식 트리가 영구적으로 저장되고 관리되는 메인 데스크톱 애플리케이션. 폴더 기반의 사이드바와 **자유로운 패닝/줌이 가능한 '전체 트리 캔버스'**로 구성되어, 과거 기록을 탐색하고 이어서 편집하는 허브 역할을 한다. 생성된 트리는 루트 노드의 질문에서 추출된 키워드를 기반으로 **자동으로 '메모' 제목이 부여**된다.

### 2.3. 노드 (Node)
지식 트리를 구성하는 기본 단위. 질문과 답변의 한 쌍(a pair)을 담고 있다.

### 2.4. Placeholder
답변이 아직 생성되지 않은 '예비 노드'. 사용자가 답변 본문에서 여러 개념을 `Multi-drag` + `Enter`로 선택했을 때, 이름표만 있는 형태로 생성된다. AI 호출 없이 노드 구조부터 빠르게 잡을 수 있게 하는 핵심 기능이다.

### 2.5. 컨텍스트 체인 (Context Chain)
루트 노드를 제외한 모든 하위 노드에서 질문을 할 때 AI에게 제공되는 문맥 정보. **오직 현재 노드부터 루트 노드까지의 직선 경로에 있는 모든 [질문+답변]의 쌍으로만 구성된다.** 형제나 사촌 노드의 정보는 컨텍스트에 포함되지 않는다.

## 3.0 사용자 플로우 (User Flows)

### 3.1. 진입: 질문의 시작 (Invocation)

#### 3.1.1. 기본 호출 (General Inquiry)
1. 사용자가 `Ctrl` 키를 두 번 연속으로 누른다.
2. 화면 위에 **질문 입력 패널만으로 구성된 플로팅 에이전트**가 나타난다.

#### 3.1.2. 앵커 호출 (Anchored Inquiry)
1. 사용자가 화면의 특정 텍스트를 마우스로 드래그하여 선택한다.
2. **드래그 상태를 유지한 채로** `Ctrl` 키를 두 번 연속으로 누른다.
3. 플로팅 에이전트가 나타나며, 질문 입력 패널에는 드래그한 텍스트를 기반으로 한 **예상 질문 칩들**이 표시된다. AI는 답변 생성 시 **화면 캡처와 함께 드래그된 앵커 텍스트를 핵심 문맥으로** 더 비중 있게 분석한다.

### 3.2. 루트 노드 생성: 탐색의 첫발

1. 사용자가 호출된 플로팅 에이전트에 첫 질문을 입력하고 `Enter`를 누른다.
2. 전송과 동시에 현재 화면의 뷰포트가 1회 캡처된다.
3. 답변이 생성되면, 플로팅 에이전트는 **처음으로 '포커스 트리 뷰'를 확장**하여 루트 노드와 답변 카드를 보여준다.

### 3.3. 트리 확장: 지식의 심화와 확장

#### 3.3.1. 깊이 확장 (자유 질문 → 단일 하위 노드 생성)
1. 답변 확인 후, 사용자는 질문 패널에 추가 질문을 입력하고 `Enter`를 누른다.
2. 이 질문은 현재 활성화된 노드의 **단일 자식 노드**로 생성되며, 즉시 답변이 채워진다.

#### 3.3.2. 폭 확장 (Multi-drag → 다중 Placeholder 생성)
1. 사용자는 답변 카드 본문에서 `Cmd/Ctrl` 키를 이용해 여러 텍스트를 선택한다.
2. `Enter` 키를 누르면, 현재 활성화된 노드 아래에 선택한 개수만큼의 **자식 노드가 Placeholder 상태로 일괄 생성**된다.

### 3.4. Placeholder 활성화: 필요 기반의 답변 생성

1. 사용자가 Placeholder 노드를 클릭하면 질문 입력창이 나타난다.
2. 질문을 입력하고 `Enter`를 누르면, AI가 답변을 생성하고 Placeholder는 완전한 '답변 카드'로 전환된다.

### 3.5. 새로운 트리 시작 (라이브러리에서)

1. 사용자는 완전히 새로운 주제의 탐색을 시작하고 싶을 때 **라이브러리 앱을 연다.**
2. 사이드바 상단이나 폴더 우클릭 메뉴의 **'새 메모' 또는 `+` 버튼을 클릭**한다.
3. 즉시 **플로팅 에이전트가 호출**되어 새 질문을 입력받을 준비를 한다.
4. 사용자가 첫 질문을 입력하고 전송하면, 해당 시점의 **화면을 새롭게 캡처**하여 별개의 컨텍스트를 가진 새로운 루트 노드를 생성한다.
5. 이 세션은 라이브러리 앱에 새로운 '메모' 항목으로 즉시 생성된다.

### 3.6. 세션 종료 및 자동 저장

1. 사용자는 플로팅 에이전트 창에 마우스를 올려 나타나는 **닫기(X) 버튼을 클릭**하여 세션을 종료한다.
2. 닫는 즉시, 현재까지의 모든 노드 트리 정보는 루트 노드의 질문을 제목으로 하여 라이브러리 앱에 **하나의 '메모'로 자동 저장**된다.

## 4.0 인터페이스 및 상호작용 (UI & Interaction)

### 4.1. 플로팅 에이전트

#### 4.1.1. 창 동작 (Window Behavior)
- **크기 조절:** 사용자는 창의 경계를 드래그하여 원하는 크기로 조절할 수 있다.
- **호버 기반 UI:** 닫기(X) 버튼과 같은 창 컨트롤 요소는 평소에는 숨겨져 있다가, 마우스 커서가 창 위에 올라왔을 때만 나타난다.
- **자동 저장 및 닫기:** 닫기 버튼은 현재의 지식 트리를 라이브러리에 안전하게 저장하고 창을 닫는 역할을 한다.

#### 4.1.2. 구성 요소
- **질문 패널:** 사용자의 텍스트 입력을 받는 주 인터페이스.
- **포커스 트리 뷰 (Focus Tree View):** 첫 답변 생성 후 나타나는 시각화 영역. **이 뷰는 자유로운 패닝/줌을 지원하지 않는다.** 대신, 현재 활성화된 노드와 그 직계 부모/자식 노드들을 자동으로 명확하게 배치하여 현재 문맥에 집중하도록 돕는다.

#### 4.1.3. 핵심 상호작용
- **노드 클릭:** 노드를 활성화하고, 하위 질문을 입력할 수 있도록 준비시킨다.
- **우클릭 메뉴:** 노드에 대고 우클릭 시 '이름 바꾸기', '삭제' 옵션 제공.
- **실행 취소:** `Ctrl+Z` 단축키로 마지막 행동(Placeholder 생성, 노드 삭제 등)을 취소.

### 4.2. 라이브러리 앱

#### 4.2.1. 구성 요소
- **사이드바:** 폴더와 메모(지식 트리)가 계층 구조로 표시되는 탐색 영역.
- **전체 트리 캔버스 (Full Tree Canvas):** 사이드바에서 메모 선택 시, 해당 지식 트리 전체가 표시되는 주 영역. **자유로운 패닝과 줌을 완벽하게 지원**하여 전체 지식 지도를 조망하고 탐색할 수 있다.

#### 4.2.2. 핵심 상호작용
- **폴더 관리:** `+ 새 폴더` 버튼, 이름 변경, 삭제, 드래그 앤 드롭을 통한 메모 이동 등 완벽한 폴더 관리 기능을 제공한다.
- **메모 관리:** '새 메모' 생성, 기존 메모 열기, 삭제가 가능하며, 메모 제목은 루트 노드 질문 기반으로 자동 생성되지만 사용자가 직접 수정할 수도 있다.
- **연속 편집:** 캔버스 내의 노드를 클릭하면 플로팅 에이전트와 동일한 UI/UX로 즉시 질문을 추가하고 트리를 이어서 편집할 수 있다.

## 5.0 아키텍처 및 데이터 (Architecture & Data)

### 5.1. 이원화 구조

- **에이전트 (실행):** 현재 작업에 개입하여 지식을 '포착'하고 '확장'하는 역할.
- **라이브러리 (저장):** 생성된 지식을 '저장'하고 '관리'하며 '재탐색'하는 역할.

### 5.2. 데이터 구조 (Node)

- `id`: string (고유 식별자)
- `keyword`: string (노드 라벨, 드래그 텍스트에서 추출)
- `question`: string | null (Placeholder 단계에선 null)
- `answer`: string | null (answered에서만 존재)
- `parentId`: string | null (루트면 null)
- `childrenIds`: string[]
- `status`: 'placeholder' | 'asking' | 'answered'
- `createdAt`: number (타임스탬프)

## 6.0 사용자 인증 및 온보딩

### 6.1. 목표
JARVIS의 효과적인 사용자 관리와 클라우드 기반 데이터 동기화를 위한 인증 시스템 구축

### 6.2. 핵심 정책

- **로그인 필수 정책**: JARVIS의 모든 기능은 로그인 후에만 사용 가능하다. 이를 통해 모든 지식 트리가 사용자 계정에 귀속되어 클라우드에 저장 및 동기화된다.
- **인증 서비스 도입**: 인증 기능 구현의 효율성 및 보안성 확보를 위해 외부 인증 서비스 [Clerk](https://clerk.com)을 사용한다.

### 6.3. 사용자 플로우: 최초 실행부터 동기화까지

#### 6.3.1. 최초 실행 및 온보딩

1. 사용자가 설치 후 처음으로 라이브러리 앱을 실행한다.
2. 서비스의 핵심 컨셉을 소개하는 온보딩 화면이 표시된다.
3. 온보딩 마지막 단계의 "시작하기" 버튼을 클릭하면 로그인 절차로 이동한다.

#### 6.3.2. 계정 생성 및 로그인

1. "시작하기" 버튼 클릭 시, Clerk이 제공하는 UI 컴포넌트 기반의 로그인 모달 창이 나타난다.
2. 사용자는 UI 내에서 Google, Apple 등의 소셜 로그인을 선택할 수 있다.
3. OAuth 인증 절차는 Clerk을 통해 처리된다.
4. 인증 성공 시, Clerk은 JWT 및 userId를 발급하여 사용자 세션을 시작한다.

#### 6.3.3. 로그인 완료 및 데이터 동기화

1. 로그인이 완료되면 로그인 모달은 닫히고, 라이브러리 앱의 메인 UI가 표시된다.
2. UI의 사용자 프로필 정보는 Clerk 프론트엔드 SDK를 통해 출력된다.
3. 이후 생성되는 모든 데이터는 백엔드에서 Clerk userId와 연결되어 저장된다.

### 6.4. 인터페이스 및 상호작용

#### 6.4.1. 온보딩 화면

- **구성**: 앱의 핵심 기능을 설명하는 이미지와 텍스트로 구성된 모달 형태.
- **상호작용**: 슬라이드 방식의 네비게이션과 '건너뛰기' 기능을 제공한다.

#### 6.4.2. 로그인 화면

- **구현 방식**: Clerk의 `<SignIn />` 컴포넌트를 직접 활용하고, 서비스 브랜딩에 맞게 UI를 커스터마이징한다.
- **상태 처리**: 로그인 과정의 UI 상태 및 오류 처리는 Clerk 컴포넌트에 위임한다.

### 6.5. 인증 상태 관리

- **세션 관리**: 사용자의 로그인 상태, 세션 토큰(JWT)의 발급, 갱신, 만료 처리는 Clerk SDK를 통해 관리한다.
- **상태 동기화**: 토큰 만료 등 세션이 무효화될 경우, 앱을 보호 상태로 전환하고 재로그인을 요청하는 로직은 Clerk SDK가 처리한다.

### 6.6. 기술 구현

- **인증 프로바이더**: [Clerk](https://clerk.com)
- **구현 사항:**
  - Clerk의 pre-built UI 컴포넌트를 사용하여 로그인/회원가입 플로우를 구현한다.
  - Clerk SDK를 사용하여 프론트엔드에서 사용자 인증 상태를 관리한다.
  - 백엔드 DB의 User 관련 테이블은 Clerk userId를 기준으로 데이터를 관리한다.
  - Clerk Webhooks를 사용하여 Clerk의 사용자 데이터 변경사항을 백엔드 DB에 동기화한다.